syntax = "proto3";
package heartbeatpb;

option go_package = "github.com/pingcap/ticdc/heartbeatpb";

message TableSpan {
    int64 TableID   = 1;
	bytes StartKey  = 2;
	bytes EndKey    = 3;
}

message HeartBeatRequest {
    ChangefeedID changefeedID = 1;
    Watermark watermark = 2;
    repeated TableSpanStatus statuses = 3;
    bool compeleteStatus = 4; // Whether includes all table spans in the changefeed?
    RunningError err = 5;
}

message Watermark {
    uint64 checkpointTs = 1; // min checkpointTs of all tables in the eventDispatcherManager
    uint64 resolvedTs = 2;   // min resolvedTs of all tables in the eventDispatcherManager
}

enum Action {
    Write = 0;
    Pass = 1;
}

message DispatcherAction {
    Action action = 1;
    uint64 CommitTs = 2; // DDLCommitTs
    bool IsSyncPoint = 3; // sync point Event and ddl Event could have the same CommitTs, so we need to distinguish them.
}

message ACK {
    uint64 CommitTs = 1; // DDLCommitTs
    bool IsSyncPoint = 2; // sync point Event and ddl Event could have the same CommitTs, so we need to distinguish them.
}

message InfluencedDispatchers {
    InfluenceType InfluenceType = 1;
    // only exist when type is normal
	repeated DispatcherID DispatcherIDs = 2; 
    // only exist when type is DB.
	int64 SchemaID = 3;
    // only exist when type is all or db, and in heartbeat response.
    DispatcherID excludeDispatcherId = 4;
}

message DispatcherStatus {
    InfluencedDispatchers influencedDispatchers = 1;
    DispatcherAction action = 2;
    ACK ack = 3;
}

message HeartBeatResponse {
    ChangefeedID changefeedID = 1;
    repeated DispatcherStatus dispatcherStatuses = 2;
}

message CheckpointTsMessage {
    ChangefeedID changefeedID = 1;
    uint64 checkpointTs = 2;
}

enum ScheduleAction {
    Create = 0;
    Remove = 1;
}

message DispatcherConfig {
    TableSpan span = 1;
    uint64 startTs = 2;
    DispatcherID dispatcherID = 3;
    int64 schemaID = 4;
    // it's the pd time when scheduling the dispatcher, for MySQL sink event before this tso should use replace mode
    uint64 current_pd_ts = 5;
}

message ScheduleDispatcherRequest {
    ChangefeedID changefeedID = 1;
    DispatcherConfig config = 2;
    ScheduleAction scheduleAction = 3;
}

message MaintainerHeartbeat {
    repeated MaintainerStatus statuses = 1;
}

message MaintainerStatus {
    ChangefeedID changefeedID = 1;
    string feed_state = 2;
    ComponentState state = 3;
    uint64 checkpoint_ts = 4;
    repeated RunningError err = 5;
}

message CoordinatorBootstrapRequest {
    int64 version = 1;
}

message CoordinatorBootstrapResponse {
    repeated MaintainerStatus statuses = 1;
}

message AddMaintainerRequest  {
    ChangefeedID id = 1;
    bytes config = 2;
    uint64 checkpoint_ts = 3;
}

message RemoveMaintainerRequest  {
    ChangefeedID id = 1;
    bool cascade = 2;
    bool removed = 3;
}

message MaintainerBootstrapRequest {
    ChangefeedID changefeedID = 1;
    bytes config = 2;
    uint64 start_ts = 3;
    DispatcherID table_trigger_event_dispatcher_id = 4;
}

message MaintainerBootstrapResponse {
    ChangefeedID changefeedID = 1;
    repeated BootstrapTableSpan spans = 2;
    RunningError err = 3;
    // when the table trigger event dispatcher is created in this node,
    // we need to return the checkpointTs(startTs) of the table trigger event dispatcher
    // This checkpointTs will be the ts to check schema store to get table lists when maintainer is restarted.
    // Because table trigger event dispatcher participates all create/delete tables ddls, 
    // so we need to align the table list with the progress of table trigger event dispatcher 
    // when it is restarted to keep correctness.
    // If the table trigger event dispatcher is not created in this node, we can return 0 as the checkpointTs.
    uint64 checkpoint_ts = 4; 
}

enum BlockStage {
    NONE = 0;
    WAITING = 1;
    WRITING = 2;
    DONE = 3;
}

message BootstrapTableSpan {
    DispatcherID ID = 1;
    int64  SchemaID = 2;
    TableSpan span = 3;
    ComponentState component_status = 4;
    uint64 checkpoint_ts = 5;
    State block_state = 6;
}

message MaintainerCloseRequest {
    ChangefeedID changefeedID = 1;
    // true when remove changefeed, false when pause the changefeed.
    bool removed = 2;
}

message MaintainerCloseResponse {
    ChangefeedID changefeedID = 1;
    bool success = 2;
}

enum InfluenceType {
    All = 0;
    DB = 1;
    Normal = 2;
}

message InfluencedTables {
    InfluenceType InfluenceType = 1;
    // only exist when type is normal
	repeated int64 TableIDs  = 2;
    // only exist when type is DB.
	int64 SchemaID = 3;
}

message Table {
    int64 TableID = 1;
    int64 SchemaID = 2;
}

message SchemaIDChange {
    int64 TableID = 1;
    int64 OldSchemaID = 2;
    int64 NewSchemaID = 3;
}

message State {
    bool IsBlocked      = 1;
    uint64 BlockTs         = 2;
    InfluencedTables BlockTables = 3;
    InfluencedTables NeedDroppedTables =4;
    repeated Table NeedAddedTables = 5;
    repeated SchemaIDChange UpdatedSchemas = 6;
    bool IsSyncPoint = 7;
    BlockStage stage = 8; // means whether the block is waiting / writing / done
}

message TableSpanBlockStatus {
    DispatcherID ID = 1; // for which dispatcher
    State state = 2;
}

message TableSpanStatus {
    DispatcherID ID = 1; // for which dispatcher
    ComponentState component_status = 2;
    uint64 checkpoint_ts = 3;
    float event_size_per_second = 4;
}

message BlockStatusRequest {
    ChangefeedID changefeedID = 1;
    repeated TableSpanBlockStatus blockStatuses = 2;
}

enum ComponentState {
    Working = 0;
    Stopped = 1;
    Removed = 2;
}

message RunningError {
    string time = 1;
    string node = 2;
    string code = 3;
    string message = 4;
}

message DispatcherID {
    uint64 high = 1;
    uint64 low = 2;
}

message ChangefeedID {
    uint64 high = 1;
    uint64 low = 2;
    string name = 3;
    string namespace = 4;
}